.. _bson_t:

======
bson_t
======

BSON Document Abstraction

Synopsis
--------

.. code-block:: c

   #include <bson/bson.h>

   /**
    * bson_empty:
    * @b: a bson_t.
    *
    * Checks to see if @b is an empty BSON document. An empty BSON document is
    * a 5 byte document which contains the length (4 bytes) and a single NUL
    * byte indicating end of fields.
    */
   #define bson_empty(b) /* ... */

   /**
    * bson_empty0:
    *
    * Like bson_empty() but treats NULL the same as an empty bson_t document.
    */
   #define bson_empty0(b) /* ... */

   /**
    * bson_clear:
    *
    * Easily free a bson document and set it to NULL. Use like:
    *
    * bson_t *doc = bson_new();
    * bson_clear (&doc);
    * BSON_ASSERT (doc == NULL);
    */
   #define bson_clear(bptr) /* ... */

   /**
    * BSON_MAX_SIZE:
    *
    * The maximum size in bytes of a BSON document.
    */
   #define BSON_MAX_SIZE /* ... */

   #define BSON_APPEND_ARRAY(b, key, val) \
      bson_append_array (b, key, (int) strlen (key), val)

   #define BSON_APPEND_ARRAY_BEGIN(b, key, child) \
      bson_append_array_begin (b, key, (int) strlen (key), child)

   #define BSON_APPEND_BINARY(b, key, subtype, val, len) \
      bson_append_binary (b, key, (int) strlen (key), subtype, val, len)

   #define BSON_APPEND_BOOL(b, key, val) \
      bson_append_bool (b, key, (int) strlen (key), val)

   #define BSON_APPEND_CODE(b, key, val) \
      bson_append_code (b, key, (int) strlen (key), val)

   #define BSON_APPEND_CODE_WITH_SCOPE(b, key, val, scope) \
      bson_append_code_with_scope (b, key, (int) strlen (key), val, scope)

   #define BSON_APPEND_DBPOINTER(b, key, coll, oid) \
      bson_append_dbpointer (b, key, (int) strlen (key), coll, oid)

   #define BSON_APPEND_DOCUMENT_BEGIN(b, key, child) \
      bson_append_document_begin (b, key, (int) strlen (key), child)

   #define BSON_APPEND_DOUBLE(b, key, val) \
      bson_append_double (b, key, (int) strlen (key), val)

   #define BSON_APPEND_DOCUMENT(b, key, val) \
      bson_append_document (b, key, (int) strlen (key), val)

   #define BSON_APPEND_INT32(b, key, val) \
      bson_append_int32 (b, key, (int) strlen (key), val)

   #define BSON_APPEND_INT64(b, key, val) \
      bson_append_int64 (b, key, (int) strlen (key), val)

   #define BSON_APPEND_MINKEY(b, key) \
      bson_append_minkey (b, key, (int) strlen (key))

   #define BSON_APPEND_DECIMAL128(b, key, val) \
      bson_append_decimal128 (b, key, (int) strlen (key), val)

   #define BSON_APPEND_MAXKEY(b, key) \
      bson_append_maxkey (b, key, (int) strlen (key))

   #define BSON_APPEND_NULL(b, key) bson_append_null (b, key, (int) strlen (key))

   #define BSON_APPEND_OID(b, key, val) \
      bson_append_oid (b, key, (int) strlen (key), val)

   #define BSON_APPEND_REGEX(b, key, val, opt) \
      bson_append_regex (b, key, (int) strlen (key), val, opt)

   #define BSON_APPEND_UTF8(b, key, val) \
      bson_append_utf8 (b, key, (int) strlen (key), val, (int) strlen (val))

   #define BSON_APPEND_SYMBOL(b, key, val) \
      bson_append_symbol (b, key, (int) strlen (key), val, (int) strlen (val))

   #define BSON_APPEND_TIME_T(b, key, val) \
     bson_append_time_t (b, key, (int) strlen (key), val)

   #define BSON_APPEND_TIMEVAL(b, key, val) \
      bson_append_timeval (b, key, (int) strlen (key), val)

   #define BSON_APPEND_DATE_TIME(b, key, val) \
      bson_append_date_time (b, key, (int) strlen (key), val)
 
   #define BSON_APPEND_TIMESTAMP(b, key, val, inc) \
      bson_append_timestamp (b, key, (int) strlen (key), val, inc)

   #define BSON_APPEND_UNDEFINED(b, key) \
      bson_append_undefined (b, key, (int) strlen (key))

   #define BSON_APPEND_VALUE(b, key, val) \
      bson_append_value (b, key, (int) strlen (key), (val))

   BSON_ALIGNED_BEGIN (128)
   typedef struct {
      uint32_t flags;       /* Internal flags for the bson_t. */
      uint32_t len;         /* Length of BSON data. */
      uint8_t padding[120]; /* Padding for stack allocation. */
   } bson_t BSON_ALIGNED_END (128);

Description
-----------

The :ref:`bson_t` structure represents a BSON document. This structure manages the
underlying BSON encoded buffer. For mutable documents, it can append new data to the
document.

Performance Notes
-----------------

The :ref:`bson_t` structure attempts to use an inline allocation within the structure
to speed up performance of small documents. When this internal buffer has been exhausted,
a heap allocated buffer will be dynamically allocated. Therefore, it is essential to call
:ref:`bson_destroy` on allocated documents.

Duplicate Keys
--------------

The `BSON specification <https://bsonspec.org>`_ allows BSON documents to have
duplicate keys. Documents are stored as an ordered list of key-value pairs. A
:ref:`bson_t` may contain duplicate keys. Applications should refrain from
generating such documents, because MongoDB server behavior is undefined when a
BSON document contains duplicate keys.

Functions
---------

.. toctree::
   :titlesonly:
   :maxdepth: 1

   /libbson/api/bson_t/bson_append_array
   /libbson/api/bson_t/bson_append_array_begin
   /libbson/api/bson_t/bson_append_array_end
   /libbson/api/bson_t/bson_append_binary
   /libbson/api/bson_t/bson_append_bool
   /libbson/api/bson_t/bson_append_code
   /libbson/api/bson_t/bson_append_code_with_scope
   /libbson/api/bson_t/bson_append_date_time
   /libbson/api/bson_t/bson_append_dbpointer
   /libbson/api/bson_t/bson_append_decimal128
   /libbson/api/bson_t/bson_append_document
   /libbson/api/bson_t/bson_append_document_begin
   /libbson/api/bson_t/bson_append_document_end
   /libbson/api/bson_t/bson_append_double
   /libbson/api/bson_t/bson_append_int32
   /libbson/api/bson_t/bson_append_int64
   /libbson/api/bson_t/bson_append_iter
   /libbson/api/bson_t/bson_append_maxkey
   /libbson/api/bson_t/bson_append_minkey
   /libbson/api/bson_t/bson_append_now_utc
   /libbson/api/bson_t/bson_append_null
   /libbson/api/bson_t/bson_append_oid
   /libbson/api/bson_t/bson_append_regex
   /libbson/api/bson_t/bson_append_regex_w_len
   /libbson/api/bson_t/bson_append_symbol
   /libbson/api/bson_t/bson_append_time_t
   /libbson/api/bson_t/bson_append_timestamp
   /libbson/api/bson_t/bson_append_timeval
   /libbson/api/bson_t/bson_append_undefined
   /libbson/api/bson_t/bson_append_utf8
   /libbson/api/bson_t/bson_append_value
   /libbson/api/bson_t/bson_array_as_canonical_extended_json
   /libbson/api/bson_t/bson_array_as_json
   /libbson/api/bson_t/bson_array_as_relaxed_extended_json
   /libbson/api/bson_t/bson_as_canonical_extended_json
   /libbson/api/bson_t/bson_as_json
   /libbson/api/bson_t/bson_as_json_with_opts
   /libbson/api/bson_t/bson_as_relaxed_extended_json
   /libbson/api/bson_t/bson_compare
   /libbson/api/bson_t/bson_concat
   /libbson/api/bson_t/bson_copy
   /libbson/api/bson_t/bson_copy_to
   /libbson/api/bson_t/bson_copy_to_excluding
   /libbson/api/bson_t/bson_copy_to_excluding_noinit
   /libbson/api/bson_t/bson_copy_to_excluding_noinit_va
   /libbson/api/bson_t/bson_count_keys
   /libbson/api/bson_t/bson_destroy
   /libbson/api/bson_t/bson_destroy_with_steal
   /libbson/api/bson_t/bson_equal
   /libbson/api/bson_t/bson_get_data
   /libbson/api/bson_t/bson_has_field
   /libbson/api/bson_t/bson_init
   /libbson/api/bson_t/bson_init_from_json
   /libbson/api/bson_t/bson_init_static
   /libbson/api/bson_t/bson_json_mode_t
   /libbson/api/bson_t/bson_json_opts_t
   /libbson/api/bson_t/bson_new
   /libbson/api/bson_t/bson_new_from_buffer
   /libbson/api/bson_t/bson_new_from_data
   /libbson/api/bson_t/bson_new_from_json
   /libbson/api/bson_t/bson_reinit
   /libbson/api/bson_t/bson_reserve_buffer
   /libbson/api/bson_t/bson_sized_new
   /libbson/api/bson_t/bson_steal
   /libbson/api/bson_t/bson_validate
   /libbson/api/bson_t/bson_validate_with_error
   
Example
-------

.. code-block:: c

  static void
  create_on_heap (void)
  {
     bson_t *b = bson_new ();

     BSON_APPEND_INT32 (b, "foo", 123);
     BSON_APPEND_UTF8 (b, "bar", "foo");
     BSON_APPEND_DOUBLE (b, "baz", 1.23f);

     bson_destroy (b);
  }

